" All system-wide defaults are set in $VIMRUNTIME/debian.vim and sourced by
" the call to :runtime you can find below.  If you wish to change any of those
" settings, you should do it in this file (/etc/vim/vimrc), since debian.vim
" will be overwritten everytime an upgrade of the vim packages is performed.
" It is recommended to make changes after sourcing debian.vim since it alters
" the value of the 'compatible' option.

" This line should not be removed as it ensures that various options are
" properly set to work with the Vim-related packages available in Debian.
runtime! debian.vim

" Vim will load $VIMRUNTIME/defaults.vim if the user does not have a vimrc.
" This happens after /etc/vim/vimrc(.local) are loaded, so it will override
" any settings in these files.
" If you don't want that to happen, uncomment the below line to prevent
" defaults.vim from being loaded.
" let g:skip_defaults_vim = 1

" Uncomment the next line to make Vim more Vi-compatible
" NOTE: debian.vim sets 'nocompatible'.  Setting 'compatible' changes numerous
" options, so any other options should be set AFTER setting 'compatible'.
"set compatible

" Vim5 and later versions support syntax highlighting. Uncommenting the next
" line enables syntax highlighting by default.
if has("syntax")
  syntax on
endif

" If using a dark background within the editing area and syntax highlighting
" turn on this option as well
"set background=dark

" Uncomment the following to have Vim jump to the last position when
" reopening a file
"if has("autocmd")
"  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
"endif

" Uncomment the following to have Vim load indentation rules and plugins
" according to the detected filetype.
"if has("autocmd")
"  filetype plugin indent on
"endif

" The following are commented out as they cause vim to behave a lot
" differently from regular Vi. They are highly recommended though.
"set showcmd		" Show (partial) command in status line.
"set showmatch		" Show matching brackets.
"set ignorecase		" Do case insensitive matching
"set smartcase		" Do smart case matching
"set incsearch		" Incremental search
"set autowrite		" Automatically save before commands like :next and :make
"set hidden		" Hide buffers when they are abandoned
"set mouse=a		" Enable mouse usage (all modes)

" Source a global configuration file if available

if filereadable("/etc/vim/vimrc.local")
  source /etc/vim/vimrc.local
endif

"se autowrite

se nocompatible
se nu
se autoindent
se mouse=a
se showcmd
se hlsearch

map \\ yyI\begin{<Esc>A}<Esc>pI\end{<Esc>A}<Esc>O


function! Promt(p)
	return "promt; echo ". <g-args> . ";" . l:p
endfunction
function! Compile()
	let file_name = expand('%:t:r')
	let extension = expand('%:e')
	w
	if l:extension == "cpp"
		execute "Bp g++ -Wall ". @% . " -o ". l:file_name . ".out " . g:compile
	else
		if l:extension == "tex"
			execute "Bp pdflatex ". @% . " " . g:compile
		else
			echo "file extention not suported"

		endif
	endif
endfunction
function! CompileMore()
	let file_name = expand('%:t:r')
	let extension = expand('%:e')
	w
	if l:extension == "cpp"
		execute "Bp g++ -Wall ". @% . " -o ". l:file_name . ".out " . g:compile . " | more"
	else
		if l:extension == "tex"
			execute "Bp pdflatex ". @% . " " . g:compile
		else
			echo "file extention not suported"

		endif
	endif
endfunction
function! Run()
	let file_name = expand('%:t:r')
	let extension = expand('%:e')
	if l:extension == "cpp"
		execute "Bp ./". l:file_name . ".out " . g:run
	else
		if l:extension == "tex"
			execute "Bp gopen ". l:file_name . ".pdf"
		else
			if l:extension == "in"
				w
				execute "Bp ./main.out ".g:compile." ". @% . " " . g:run 
			else
				echo "file extention not suported"
			endif
		endif
	endif
endfunction
function! CompileRun()
	let file_name = expand('%:t:r')
	let extension = expand('%:e')
	w
	if l:extension == "cpp"
		execute "PriparePromt rm ./". l:file_name . ".out"
		let l:r =  g:promt . "; "
		execute "PriparePromt g++ -Wall ". @% . " -o ". l:file_name . ".out " . g:compile
		let l:r = l:r . g:promt . "; "
		execute "PriparePromt ./". l:file_name . ".out " . g:run
		let l:r = l:r . g:promt
		execute "B " . l:r
	else
		if l:extension == "tex"
			execute "PriparePromt pdflatex ". @% . " " . g:compile
			let l:r = g:promt . "; "
			execute "PriparePromt gopen ". l:file_name . ".pdf"
			let l:r = l:r . g:promt
			execute "B " . l:r
		else
			echo "file extention not suported"
		endif
	endif
endfunction
function! ClearCompile()
	let file_name = expand('%:t:r')
	let extension = expand('%:e')
	w
	if l:extension == "cpp"
		execute "PriparePromt g++ -Wall ". @% . " -o ". l:file_name . ".out " . g:compile
		let l:r = "clear;clear;" . g:promt
		execute "B " . l:r
	else
		if l:extension == "tex"
			execute "PriparePromt pdflatex ". @% . " " . g:compile
			let l:r = "clear;clear;" . g:promt
			execute "B " . l:r
		else
			execute "Bp gopen ". l:file_name . ".pdf"
		endif
	endif
endfunction
function! Debug()
	let file_name = expand('%:t:r')
	let extension = expand('%:e')
	w
	if l:extension == "cpp"
		execute "PriparePromt rm ./". l:file_name . ".out"
		let l:r =  g:promt . "; "
		execute "PriparePromt g++ -Wall ". @% . " -o ". l:file_name . ".out -g3  " . g:compile
		let l:r = l:r . g:promt . "; "
		execute "PriparePromt gdb ./". l:file_name . ".out"
		let l:r = l:r . g:promt
		execute "B " . l:r
	else
		echo "file extention not suported"
	endif
endfunction
function! Help()
	sp|view  /usr/share/vim/help
endfunction
function! BasicFile()
	let file_name = expand('%:t:r')
	let extension = expand('%:e')
	execute "r /usr/share/vim/basicFile." . extension  
endfunction
function! Git()
	let file_name = expand('%:t:r')
	let extension = expand('%:e')
	w
		execute "PriparePromt git add ."
		let l:r =  g:promt . "; "
		execute "PriparePromt git commit"
		let l:r = l:r . g:promt . "; "
		execute "PriparePromt git pull"
		let l:r = l:r . g:promt . "; "
		execute "PriparePromt git push"
		let l:r = l:r . g:promt 
		execute "B " . l:r
endfunction
command! -nargs=+ B Bnexit <args>; exit
command! -nargs=* Bs  B sepLine; <args>
command! -nargs=* Bp  B promt; echo <q-args>; <args>
command! -nargs=* Bsp  B sepLine; promt; echo <q-args>; <args>
command! -nargs=+ Bnexit  !bash -i -c <q-args>
command! -nargs=+ WripeInPromt  let g:promt = <q-args>
command! -nargs=+ PriparePromt  WripeInPromt promt; echo <q-args>; <args>
"cmap <C-b> <Home><Right><BS>B<Space><CR>
let g:compile = ""
let g:run = ""
map \c :call Compile()<CR>
map \C :call ClearCompile()<CR>
map \r :call Run()<CR>
map \R :call CompileRun()<CR>
map \k :call Kasiopea()<CR>
map \d :call Debug()<CR>
map \i :let g:compile = ""<Left>
map \I :let g:run = ""<Left>

map \h :call Help()<CR>

map \f :call BasicFile()<CR><Up>dd

map \s :se spell<CR>:se spelllang=cs<CR>

map \g :call Git()<CR>


"map  <C-Down> gj
"imap <C-Down> <C-o>gj
"map  <C-Up>   gk 
"imap <C-Up>   <C-o>gk 
imap <silent> <C-Up> <C-o>gk
imap <silent> <C-Down> <C-o>gj
map <silent> <C-Up> gk
map <silent> <C-Down> gj

map <silent> <C-c> "+y
vmap <silent> <C-c> "+y
map <silent> <C-x> "+d
vmap <silent> <C-x> "+d
imap <silent> <C-v> <C-r>+

let g:compile = "-DDEB"
function! Kasiopea()
	let file_name = expand('%:t:r')
	let extension = expand('%:e')
	w
	if l:extension == "cpp"
		execute "PriparePromt rm ./". l:file_name . ".out"
		let l:r =  g:promt . "; "
		execute "PriparePromt g++ -Wall ". @% . " -o ". l:file_name . ".out " 
		let l:r = l:r . g:promt . "; "
		execute "PriparePromt ./f.sh ".l:file_name
		let l:r = l:r . g:promt
		execute "B " . l:r
	else
		echo "file extention not suported"
	endif
endfunction
