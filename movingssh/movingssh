#!/bin/bash

msgOut="&2"

usernameDefault="$USER"
usernameSpec=""
mkdir -p ~/m
mkdir -p ~/.movingssh

####################### PARSE ARG #######################################
for var in "$@"
do
	if [[ "$name" == "" ]]
	then
		if [[ "$var" == -* ]]
		then
			minus="$minus$var"
		else
			name="$var"
		fi
	else
		parametrs="$parametrs $var"
	fi
done

name="$name"
while [[ "${name:0:1}" == '_' ]]
do
	name="${name:1}"
done

if [[ -f ~/.movingssh/config ]]
then
	. ~/.movingssh/config
fi
####################### HELP #######################################
if [[ "$minus" == *"h"* ]]
then
	cat <<EOF
Auomatic ssh conect to device without private addrees by local ip starage at server or ssh tunel
Usage:
	movingssh [-parametrs] [user@]device [ssh command parametrs]

Parametrs:
	-h	print this help
	-b	print debuging messages
	-p	print address and port to connect
	-d	download new pozition just after run
	-D	do not download new pozition
	-x	do not run parralel
	-l	force use local conection
	-r	force use remote conection
	-m	sshfs mount
	-u	umount
	-U	force umount
	-t	Make tunel
	-T	Delete tunel route
	-v  Connect x11vnc session view only
	-V  Connect x11vnc session with control
	-c  Connect vnc session
	-n  Do not tunel X server by -Y
	-N  Do not tunel X server by -Y, tunel it only by -X
	-g 	Only print addres for use
EOF
	exit 0
fi

####################### PARSE ARG #######################################
xtunelCMD="-Y"
[[ "$minus" == *"N"* ]] && xtunelCMD="-X"
[[ "$minus" == *"n"* ]] && xtunelCMD=""
[[ "$minus" == *"v"* ]] && xtunelCMD=""
[[ "$minus" == *"V"* ]] && xtunelCMD=""
[[ "$minus" == *"c"* ]] && xtunelCMD=""

if [[ "$name" == "" ]]
then
	echo NO ARGUMENTS >$msgOut
	exit 0
fi
if [[ "$name" == *"@"* ]]
then
	usernameSpec="$(echo "$name" | cut -d'@' -f1)"
	name="$(echo "$name" | cut -d'@' -f2)"
fi
timeout=2
sleepTime=10

####################### PARSE ARG #######################################
addressFile=~/.movingssh/address/$name
tunelFile=~/.movingssh/tunel/$name
configFile=~/.movingssh/configDevice/$name
mkdir -p ~/.movingssh/address/
mkdir -p ~/.movingssh/tunel/
mkdir -p ~/.movingssh/configDevice/
mountpoint=~/m/$name
servermountpoint=/
[[ "$MS_MOUNTPOINT" != "" ]] && mountpoint="$MS_MOUNTPOINT"
[[ "$MS_SERVERMOUNTPOINT" != "" ]] && servermountpoint="$MS_SERVERMOUNTPOINT"

pipeFile=$(mktemp -u)
mkfifo $pipeFile
exec 3<>$pipeFile
rm $pipeFile

timeoutCMD="-o ConnectTimeout=$timeout"
envCMD="-o SendEnv=LD_SSHTYPE"
keyCMD="-o HostKeyAlias=$name"

[[ "$downloadServer" == "" ]] && downloadServer="jirikalvoda@kam.mff.cuni.cz"


debug()
{
	if [[ "$minus" == *"b"* ]]
	then
		echo DEBUG: $@  >$msgOut
	fi
}

kilrek()
{
	pgrep -P $1 | while read p;
	do
		kilrek $p;
		#echo $p;
		kill $p;
	done
}
killallmy()
{
	pgrep -P $$ |  while read p;
	do
		name=$(ps -p $p -o comm=)
		if [[ " $* " == *"$name"* ]]
		then
			debug KILL $p $name
			kill $p
		fi
	done
}


parseConfig()
{
	debug PARSE CONFIG
	#shopt -s extglob
	declare -g -A config
	if [ -f "$addressFile" ]
	then
		while IFS='= ' read -r lhs rhs
		do
		    if [[ ! $lhs =~ ^\ *# && -n $lhs ]]; then
			rhs="${rhs%%\#*}"    # Del in line right comments
			rhs="${rhs%%*( )}"   # Del trailing spaces
			rhs="${rhs%\"*}"     # Del opening string quotes 
			rhs="${rhs#\"*}"     # Del closing string quotes 
			config[$lhs]="$rhs"
		    fi
		done < $addressFile
	else
		if [ -d ~/.movingssh/groups ]
		then
			for i in  ~/.movingssh/groups/*
			do
				. $i
			done
		fi
	fi
	if [[ "$1" != "notunel" ]] && [ -f $tunelFile ] 
	then
		while IFS='= ' read -r lhs rhs
		do
			if [[ ! $lhs =~ ^\ *# && -n $lhs ]]; then
			rhs="${rhs%%\#*}"    # Del in line right comments
			rhs="${rhs%%*( )}"   # Del trailing spaces
			rhs="${rhs%\"*}"     # Del opening string quotes 
			rhs="${rhs#\"*}"     # Del closing string quotes 
			config[$lhs]="$rhs"
			fi
		done < $tunelFile
	fi
	[ -f "$configFile" ] && . $configFile
	if [[ $usernameSpec == "" ]]
	then
		username="$usernameDefault"
	else
		username="$usernameSpec"
	fi
}
printAddres()
{
	if [[ "$minus" == *"p"* ]]
	then
		(
		echo A: ${config[ipA]} ${config[portA]}  >$msgOut
		echo B: ${config[ipB]} ${config[portB]}  >$msgOut
		) | column -t -N \ ,ip,port
	fi
}
download()
{
	[[ "$noDownload" != "" ]] && return
	if [[ "$minus" == *"D"* ]]
	then
		return 0
	fi
	debug DOWNLOAD
	newConfigFile=$(mktemp)
	ssh $downloadServer  $timeoutCMD "cat /home/jirikalvoda/.movingssh/address/$name" > $newConfigFile 2>/dev/null
	if [[ $? = 0 ]]
	then
		debug DOWNLOAD OK
		diff $addressFile $newConfigFile -q >/dev/null
		if [[ $? != 0 ]]
		then
			debug DIFF CONFIG
			cat $newConfigFile > $addressFile
			parseConfig
			printAddres
			rm $newConfigFile
			return 1
		fi
		rm $newConfigFile
		return 0
	else
		debug NO NET
		rm $newConfigFile
		return 0
	fi
}
tryLocal()
{
	debug TRY LOCAL
	#declare -p config
	if [[ "${config[portA]}" == "" ]]
	then
		config[portA]=22
	fi
	if [[ "${config[ipA]}" == "" ]]
	then
		ret=
		debug LOCAL NO IPA
	else
		ret=$(LD_SSHTYPE=local ssh $envCMD $username@${config[ipA]} -p${config[portA]} $keyCMD $timeoutCMD echo OK 2>/dev/null)
	fi
	if [ "$ret" = "OK" ]
	then
		debug LOCAL OK
		echo YES >&3
		killallmy sleep ssh
		return 1
	fi
	debug LOCAL NO
	return 0
}
tryLocalDownload()
{
	tryLocal
	if [[ $? == 1 ]]
	then
		return;
	fi
	if [[ "$minus" == *"d"* ]]
	then
		return;
	fi
	download
	if [[ $? == 0 ]]
	then
		killallmy sleep
		return
	fi
	tryLocal
	killallmy sleep
}

x11vnc()
{
	vncTunelPort=$(( 40000 + $RANDOM % 10000 ))
	echo "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" >$msgOut
	echo "XXX              PORT $vncTunelPort             XXX" >$msgOut
	echo "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" >$msgOut
	sudoCmd=""
	passwdFile=$(mktemp)
	head -c100 /dev/random | shasum | head -c30 > $passwdFile
	[[ "$SUDO" != "" ]] && sudoCmd="sudo -u $SUDO" 
	[[ "$VNCDISPLAY" == "" ]] && VNCDISPLAY=":0"
	vncviewerOpt=""
	[[ "$minus" == *"V"* ]] || vncviewerOpt="-ViewOnly"
	(sleep 1; while true; do VNC_PASSWORD="$(cat $passwdFile)" vncviewer $vncviewerOpt localhost::$vncTunelPort ; done ) &
	cat $passwdFile | ssh -t $envCMD $username@$1 -p$2 $keyCMD -L$vncTunelPort:localhost:$vncTunelPort $sudoCmd bash -c "\"cat | x11vnc -localhost -display $VNCDISPLAY -autoport  $vncTunelPort -forever -passwdfile /dev/stdin\""
	r=$(ssh -t $envCMD $username@$1 -p$2 $keyCMD $sudoCmd bash -c" \"pkill -f autoport\\\" $vncTunelPort\\\" ; echo -n OK\$?\"")
	[[ "$r" != "OK0" ]] && echo -e "\e[31;1m### CLEAN FAILD $r ####\e[0m" >$msgOut
	rm $passwdFile
	killallmy movingssh
}

vncserver()
{
	vncDisplay=$(( $RANDOM % 900 + 100 ))
	vncTunelPort=$(( 5900 + $vncDisplay ))
	echo "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" >$msgOut
	echo "XXX              PORT $vncTunelPort             XXX" >$msgOut
	echo "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" >$msgOut
	sudoCmd=""
	passwdFile=$(mktemp)
	head -c100 /dev/random | shasum | head -c30 > $passwdFile
	[[ "$SUDO" != "" ]] && sudoCmd="sudo -u $SUDO" 
	(sleep 0.5; while true; do VNC_PASSWORD="$(cat $passwdFile)" vncviewer  localhost::$vncTunelPort ; done ) &
	( cat $passwdFile; echo; cat $passwdFile; echo ;echo n; cat ) | ssh -t $envCMD $username@$1 -p$2 $keyCMD -L$vncTunelPort:localhost:$vncTunelPort $sudoCmd bash -c " \"vncpasswd ; vncserver :$vncDisplay\""
	r=$(ssh -t $envCMD $username@$1 -p$2 $keyCMD $sudoCmd bash -c" \"pkill -f Xvnc\\\" :$vncDisplay -auth\\\" ; echo -n OK\$?\"")
	[[ "$r" != "OK0" ]] && echo -e "\e[31;1m### CLEAN FAILD $r ####\e[0m" >$msgOut
	rm $passwdFile
	killallmy movingssh
}

printGetAddres()
{
	case $(echo $parametrs) in
		P)
			echo $username@$1 -P$2
			;;
		p)
			echo $username@$1 -P$2
			;;
		"rsync")
			echo $username@$1:
			echo -e=\'ssh $envCMD -p$2  $keyCMD\'
			;;
		*)
			echo $username $1 $2
			;;
	esac
	sleep $timeout
}

conect()
{
	if [[ "$minus" == *"g"* ]]
	then
		printGetAddres "$@"
		return 255
	fi
	if [[ "$minus" == *"v"* ]] || [[ "$minus" == *"V"* ]]
	then
		x11vnc $@
		return $?
	elif [[ "$minus" == *"c"* ]]
	then
		vncserver $@
		return $?
	else
		debug RUN: ssh $envCMD $username@$1 -p$2 $xtunelCMD $keyCMD $parametrs
		ssh $envCMD $username@$1 -p$2 $xtunelCMD  $keyCMD $parametrs
		return $?
	fi
}

remote()
{
	debug REMOTE
	if [[ "${config[portB]}" == "" ]]
	then
		config[portB]=22
	fi
	if [[ "${config[ipB]}" == "" ]]
	then
		return 255
	else
		LD_SSHTYPE=remote conect ${config[ipB]} ${config[portB]}
		return $?
	fi
}
local()
{
	debug LOCAL
	if [[ "${config[portA]}" == "" ]]
	then
		config[portA]=22
	fi
	if [[ "${config[ipA]}" == "" ]]
	then
		return 255
	else
		LD_SSHTYPE=local conect ${config[ipA]} ${config[portA]}
		return $?
	fi
}

if [[ "$minus" == *"T"* ]]
then
	rm $tunelFile
fi

parseConfig
printAddres
if [[ "$minus" == *"u"* || "$minus" == *"U"* ]]
then
	if [[ -d "$mountpoint"  ]]
	then
		if [[ "$minus" == *"U"* ]]
		then
			umount -l  $mountpoint
		else
			umount  $mountpoint
		fi
		if [ $? != 0 ]
		then
			echo UMOUNT FAILD >$msgOut
			rmdir $mountpoint
			exit 100
		fi
		rmdir $mountpoint
	else
		echo DIRECTORY $mountpoint NOT EXISTS >$msgOut
		exit 100
	fi
	exit 0
fi
if [[ "$minus" == *"d"* ]]
then
	download
fi
if [[ "$minus" == *"t"* ]]
then
	parseConfig notunel
	tunelPort=$(( 40000 + $RANDOM % 10000 ))
	echo -e "ipB=localhost\nportB=$tunelPort" > $tunelFile >$msgOut
	echo -e "\e[4;1;31mSSH TUNEL TO $name ON PORT $tunelPort \e[0m" >$msgOut
	ssh -p 443 jirikalvoda@sneaky.kam.mff.cuni.cz -L $tunelPort:${config[ipB]}:${config[portB]} "read"
	echo END >$msgOut
	rm $tunelFile
	exit 0
fi
if [[ "$minus" == *"l"* ]]
then
	local
elif [[ "$minus" == *"r"* ]]
then
	remote
elif [[ "$minus" == *"x"* ]] || [[ "$minus" == *"v"* ]] || [[ "$minus" == *"V"* ]] || [[ "$minus" == *"c"* ]]

then
	tryLocalDownload
	echo NO >&3
	if [ "$(head -n1 <&3)" == "YES" ]
	then
		echo LOCAL >$msgOut
		local
	else
		echo '********REMOTE**********' >$msgOut
		remote
	fi
elif [[ "$minus" == *"m"* ]]
then
	if [[ -d "$mountpoint" || -f "$mountpoint" ]]
	then
		rmdir $mountpoint
	fi
	if [[ -d "$mountpoint" || -f "$mountpoint" ]]
	then
		echo DIRECTORY $mountpoint EXISTS >$msgOut
		echo Unmout it first please >$msgOut
		exit 100
	fi
	tryLocalDownload
	echo NO >&3
	mkdir $mountpoint
	if [ "$(head -n1 <&3)" == "YES" ]
	then
		echo LOCAL >$msgOut
		LD_SSHTYPE=local sshfs -o follow_symlinks -C $username@${config[ipA]}:$servermountpoint -p ${config[portA]} $keyCMD $mountpoint
	else
		echo '********REMOTE**********' >$msgOut
		LD_SSHTYPE=remote sshfs  -o follow_symlinks -C $username@${config[ipB]}:$servermountpoint -p ${config[portB]} $keyCMD $mountpoint
	fi
else
	tryLocalDownload &
	remote
	if [ $? = 255 ]
	then
		sleep $sleepTime
	fi
	echo NO >&3
	if [ "$(head -n1 <&3)" == "YES" ]
	then
		parseConfig
		local
	fi
fi


exec 3>&-
pgrep -P $BASHPID | while read p;
do
	kilrek $p;
done
